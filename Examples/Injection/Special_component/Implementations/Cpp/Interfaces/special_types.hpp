/*++

Copyright (C) 2019 Special Numbers developers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++-Header file with basic types in
order to allow an easy use of Special Numbers library

Interface version: 1.0.0

*/

#ifndef __SPECIAL_TYPES_HEADER_CPP
#define __SPECIAL_TYPES_HEADER_CPP


/*************************************************************************************************************************
 Scalar types definition
**************************************************************************************************************************/

#ifdef SPECIAL_USELEGACYINTEGERTYPES

typedef unsigned char Special_uint8;
typedef unsigned short Special_uint16 ;
typedef unsigned int Special_uint32;
typedef unsigned long long Special_uint64;
typedef char Special_int8;
typedef short Special_int16;
typedef int Special_int32;
typedef long long Special_int64;

#else // SPECIAL_USELEGACYINTEGERTYPES

#include <stdint.h>

typedef uint8_t Special_uint8;
typedef uint16_t Special_uint16;
typedef uint32_t Special_uint32;
typedef uint64_t Special_uint64;
typedef int8_t Special_int8;
typedef int16_t Special_int16;
typedef int32_t Special_int32;
typedef int64_t Special_int64 ;

#endif // SPECIAL_USELEGACYINTEGERTYPES

typedef float Special_single;
typedef double Special_double;

/*************************************************************************************************************************
 General type definitions
**************************************************************************************************************************/

typedef Special_int32 SpecialResult;
typedef void * SpecialHandle;
typedef void * Special_pvoid;

/*************************************************************************************************************************
 Version for Special
**************************************************************************************************************************/

#define SPECIAL_VERSION_MAJOR 1
#define SPECIAL_VERSION_MINOR 0
#define SPECIAL_VERSION_MICRO 0
#define SPECIAL_VERSION_PRERELEASEINFO ""
#define SPECIAL_VERSION_BUILDINFO ""

/*************************************************************************************************************************
 Error constants for Special
**************************************************************************************************************************/

#define SPECIAL_SUCCESS 0
#define SPECIAL_ERROR_NOTIMPLEMENTED 1
#define SPECIAL_ERROR_INVALIDPARAM 2
#define SPECIAL_ERROR_INVALIDCAST 3
#define SPECIAL_ERROR_BUFFERTOOSMALL 4
#define SPECIAL_ERROR_GENERICEXCEPTION 5
#define SPECIAL_ERROR_COULDNOTLOADLIBRARY 6
#define SPECIAL_ERROR_COULDNOTFINDLIBRARYEXPORT 7
#define SPECIAL_ERROR_INCOMPATIBLEBINARYVERSION 8

/*************************************************************************************************************************
 Declaration of handle classes 
**************************************************************************************************************************/

typedef SpecialHandle Special_Base;
typedef SpecialHandle Special_SpecialVariable;

typedef struct {
	// TODO: minimal type safety:
	// Add some form of Identifier which class in which component this Table belongs to
	// e.g. Path to concrete class via: schema/version/ClassName//schema/version/ClassName// ...
	void* m_pfnReleaseOwnership;
	void* m_pfnAcquireOwnership;
	void* m_pfnGetLastError;
} Special_FunctionTableRequired;


typedef struct : public Special_FunctionTableRequired {
	// additional functions
} Special_FunctionTableBase;


// this does not work
//typedef struct Special_FunctionTableVariable : public Special_FunctionTableBase {
//	// base class members
//	// Problem: 
//	//	what happens if Special Baseclass adds members that should not be exposed in ?
//	//  solution: only expose "required" methods of base class here.
//
//	// additional functions
//	void* m_pfnSetValue;
//	void* m_pfnGetValue;
//	void* m_pfnGetSpecialValue;
//} Special_FunctionTableVariable;

typedef struct Special_FunctionTableSpecialVariable : public Special_FunctionTableRequired {
	// additional functions:
	// base class functions Numbers::Base
	// base class functions Numbers::Variable
	void* m_pfnSetValue;
	void* m_pfnGetValue;
	// concrete class functions Numbers::Variable
	void* m_pfnGetSpecialValue;
} Special_FunctionTableSpecialVariable;

typedef struct {
	SpecialHandle m_hHandle;
	Special_FunctionTableRequired* m_pFunctionTable;
} SpecialExtendedHandle;

namespace Special {

} // namespace Special;

// define legacy C-names for enums, structs and function types

#endif // __SPECIAL_TYPES_HEADER_CPP
